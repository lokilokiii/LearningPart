# 文件输入输出

## 输入输出格式化

### printf

%[flags] [width] [.prec] [hlL] type

flag: 符号

width：输出的宽度大小

.prec：保留小数点位数

hlL：

```c
printf("%*d", 6, 123); //这里的星号让输出的指定长度变成一个参数，更加灵活
```



<img src="D:\科协学习报告\c\输出正数格式.png" alt="输出正数格式" style="zoom: 67%;" />

![类型](D:\科协学习报告\c\类型.png)

```c
//怎么用n
printf("%d%n\n", 123456, &num); //到n之前输入的字符数，注意取地址符一定要有
```



### scanf()

***** ：跳过

```c
scanf("%*d%d", &num); //这里会跳过第一个输入，直接读入第二个输入
```

**[...]** :未待完续



## 文件输入输出

所有文件的内容都以二进制形式存储。但是，如果文件最初使用二进制编码的字符表示文本，那么该文件就是文本文件，其中包含文本内容。如果文件中的二进制代表机器语言代码或者数值数据或图片或音乐代码，该文件就是二进制文件，其中包含二进制内容

c有两种访问文件的途径：二进制模式和文本模式。

c程序会自动打开三个文件：标准输入（stdin(standard input))，标准输出（stdout(standard output)）

​        										标准错误输出（standard error output)

在默认情况下，标准输入设备为键盘，标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。

```c
#include<stdio.h>
#include<stack>

int main(int argc, char *argv[])
{
	int ch;
	FILE* fp;  //文件指针
	unsigned long count = 0;
	if (argc != 2)
	{
		printf("Usage:%s filename\n", argv[0]);
        //关闭所有打开的文件并结束程序
		exit(EXIT_FAILURE);  
	}
	if ((fp = fopen(argv[1], "r")) == NULL) 
	{
		printf("Can't open %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}
	while ((ch = getc(fp)) != EOF)
	{
		putc(ch, stdout);  //stdout是与标准输出相关联的文件指针
		count++;
	}
	fclose(fp);
	printf("File %s has %lu characters\n", argv[1], count);
	return 0;
}
```

1. **`exit()`** 

   关闭所有打开的文件并结束程序，其中的参数被传递给操作系统，供其他程序使用。正常结束的程序传递0，一场结束的程序传递非零值（不同的推出值可用于区分程序失败的不同原因）

2. **`EXIT_SUCCESS`和`EXIT_FAILURE`**

   标准要求返回值0和`EXIT_SUCCESS`表示成功结束程序，而宏`EXIT_FAILURE`用于表明结束程序失败

   [^ ]: exit(0) 和 return 0,效果相同

3. **`getc()`**

   与`getchar()`类似，但是其中含有参数，表示使用的文件

   例如，从标准输入中获取一个字符 `ch = getc(fp)` ，表示从fp指定的文件中获取一个字符

4. **`putc()`** 

   与`putchar()` 类似，但其中包含两个参数，第一个参数是带写入的字符，第二个是文件指针

   `putc(ch, fpout)` ，把字符ch当如FILE指针fpout指定的文件中 

5. **`EOF`**

   从文件中读取数据的程序在读到文件结尾到停止，`getc()`函数在读取一个字符时发现时文件结尾，它将返回一个特殊值EOF，即只有**读到超过文件末尾**时才会发现文件的末尾。

6. **`fclose()`**

   关闭指定文件，必要时刷新缓冲区
   
7. **argc和argv参数**

   argc为整数，指明传入的参数个数，查看是否有命令行参数

   argv为指针的指针

   两者用于项main函数传递程序启动时的相关信息

   argv[0]指向程序运行时的全路径名称；argv[1]指向程序在命令中执行程序名后的第一个字符串；argv[2]指向执行程序名后的第二个字符串

### 文件打开 - fopen()

`> 12.out`  `< 12.in` `> 12.in`

打开文件的标准代码：

```c
FILE* fp = fopen("file", "r");  //fp是文件指针
if (fp) {
	fscanf(file....);
    fclose(fp);
}else printf("输入错误")；
```



举个例子：

```c
int save(Student aStu[], int number){
    int ret = -1;	
    FILE* fp = fopen("file", "w");
/* r参数：打开只读； r+：打开读写，从文件头开始；     w参数：打开只写，如果不存在则新建，如果存在则清空
   w+参数：打开读写，如果不存在则新建，如果存在则清空；  a参数：打开追加，如果不存在则新建，如果存在则从    ..x参数：只新建，如果文件已经存在则不能打开               文件尾开始
*/
	 if (fp) {  //此处的student为一个结构体数据类型
   		ret = fwrite(aStu, sizeof(Student), number, fp);
   			 //写入number个aStu，每个大小为sizeof(Student),写进fp中
    	fclose(fp);
	  }
		else return ret == number; //如果写入成功返回-1，否则返回0；
}
```

任何一种“w”模式会先清空，在进行写入

### 文件I/O函数

#### fprintf() & fscanf()

两者与scanf和printf功能上都一样，但是两者都把FILE指针作为第一个参数

**rewind()**函数可以让程序回到==文件开始处==，接受一个文件指针作为参数

#### fgets() & fputs()

`fgets(char* buf, STLEN, FILE* fp)`

含有三个参数，第一个表示存储输入位置的地址，第二个参数是带输入字符串的大小，打三个是指定待读取的文件

读取输入到 第一个换行符后面 或者文件结尾 或者读取STLEN-1个字符



`fputs(buf,fp)`

buf存储字符串指针，fp用于指定文件



#### fseek()文件定位 & ftell()

<img src="D:\科协学习报告\c\文件\fseek()类型.png" alt="fseek()类型" style="zoom:150%;" />

fseek()具有三个参数

1. 第一个参数是FILE指针，指向带查找的文件，此时fopen()应该已经打开文件

2. 第二个参数是偏移量，指从起始点开始要移动的距离，==必定是一个long类型值== ,正（前移动），负（后移）、0（保持不动）

   n L:表示偏移量为 n 个字节

3. 第三个参数是模式，确定起始点

   | 模式     | 偏移量起始点 |
   | -------- | ------------ |
   | SEEK_SET | 文件开始     |
   | SEEK_CUR | 当前位置     |
   | SEEK_END | 文件末尾     |

一切正常返回0，否则返回-1



ftell()函数返回当前位置





