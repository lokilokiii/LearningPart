## 存储类别

### 作用域

作用域描述程序中可访问标识符的区域，一个c变量的作用域可以是**块作用域**、**函数作用域**、**函数原型作用域**或**文件作用域**。

### 链接

c变量有3种链接属性：外部链接、内部链接或无链接。

> 具有块作用域、函数作用域或函数原型作用域的变量都是**无链接变量**。这些变量属于定义他们的块、函数或原型私有
>
> 具有文件作用域的变量可以实外部链接或内部链接，其中**外部链接变量**可以在多文件程序中使用，**内部链接变量**只能在一个翻译单元（即一个源代码文件和它所包含的头文件）中使用。

“内部链接的文件作用域” ：文件作用域（仅限于**一个翻译单元**）

“外部链接的文件作用域” ：全局作用域 或 程序作用域

:question:那么怎么知道文件作用域变量是内部链接还是外部链接的呢！

* 查看外部定义中是否使用了存储类别说明符`static`

  ```c
  int c = 2; //文件作用域，外部链接
  static int d = 3; //文件作用域，内部链接
  int main()
  {
      return 0;
  }
  ```

  指，

  * 该文件和同一程序的**其他文件**都可以使用变量c

  * 但是变量d属于**文件私有**，该文件中的任意函数都可以使用它



### 存储期

作用域和链接描述了**标识符的可见性**，那么存储期则是用来描述通过这些标识符访问的对象的**生存期**

C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期

1. 静态存储期

   那么它在程序的执行期间一直存在，**所有文件作用域变量**都具有静态存储期。

   对于文件作用域变量，关键字 `static`表明其链接属性（具有内部链接），而并非存储期

2. 线性存储期

   > 用于并发程序设计，程序执行可被分为多个线程，具有线程存储期的对象，从被声明时到线程结束一直存在，以关键词`_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份。

   疑惑:question:什么东西，啥也不知道，不理解

   下次再来理解吧  ~~因为查不到资料~~ :cry:

3. 自动存储期

   * 块作用域的变量通常都具有自动存储期。

     当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。相当于，把自动变量占用的内存视为一个可重复使用的工作区或暂存区。

   * 然而，**块作用域变量也能具有静态存储期**，为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键词`static`

     ```c
     int aaa(int a, int b)
     {
     	int result;
         static int pro = 0;
         ...
         return result;
     }
     ```

     * 变量pro存储在静态内存中，它从程序被载入到程序结束期间都存在，但是它的作用域定义在**`aaa()`函数块**中。**只有在执行该函数时**，程序才能使用pro访问它所指定的对象（<font color="grey">该函数可以给其他函数提供该存储区的地址来简介访问该对象，例如通过指针形参或返回值</font>）



| 存储类别         | 存储期 | 作用域 | 链接 | 声明方式                       |
| ---------------- | ------ | ------ | ---- | ------------------------------ |
| 自动`auto`       | 自动   | 块     | 无   | 块内                           |
| 寄存器`register` | 自动   | 块     | 无   | 块内，使用关键词`register`     |
| 静态外部链接     | 静态   | 文件   | 外部 | 所有函数外                     |
| 静态内部链接     | 静态   | 文件   | 内部 | 所有函数外，使用关键词`static` |
| 静态无链接       | 静态   | 块     | 无   | 块内，使用关键词`static`       |



# linux段管理

![cpp_memory_layout](D:\KEXIEORGANIZATION\c\内存管理\cpp_memory_layout.jpg)

在linux下内存分配是以页为单位的，而页是通过段管理，各个段之间是独立的方便管理。

![cpp_segment_example](D:\KEXIEORGANIZATION\c\内存管理\cpp_segment_example.jpg)我们从上图基本理解内存的存放，注意上图仅仅为我们介绍了**目标文件**

什么是**目标文件**？

> 目标文件是编译阶段的真实输出，它主要是机器代码，但是具有允许链接器查看其中的符号以及工作所需的符号信息（符号，基本上是全局对象、函数等的名称）
>
> 链接器所获取所有这些目标文件，并将他们组合成一个可执行文件（假设它可以，即：没有任何重复或未定义的符号）

目标文件事实上就是编译后的文件本身，通过链接所有目标文件就可以形成一个可执行文件

目标文件主要分为3种（<font color="red">后面再详细了解</font>）：

1. **可重定位目标文件**

   包含可以在

2. **共享对象文件**

   可以在加载时或运行时动态加载的特殊类型的可重定位目标文件，

3. **可执行目标文件**



目标文件或者可执行文件中，主要分为四大块：**File Header**,**.text section**,**.data section** ,**.bss section**

![page1-225px-Program_memory_layout.pdf](D:\KEXIEORGANIZATION\c\内存管理\page1-225px-Program_memory_layout.pdf.jpg)总体内存分布情况为以上图片所示

![cpp_segment_layout](D:\KEXIEORGANIZATION\c\内存管理\cpp_segment_layout.png)

* **init段**

  程序初始化入口代码

* **bss段**

  bss段属于静态内存分配。通常是指用来存放程序中**未初始化的全局变量**和**未初始化的局部静态变量**。

  这两者默认值是0

  在程序运行时，才会给BSS段里面的变量分配空间

  在目标文件（`*.o`）和可执行文件中，BSS段只是为两种变量预留位置，并没有内容，不占据空间

  section table中保存了BSS段（未初始化的全局变量和未初始化的局部静态变量）内存空间大小的总和，可以通过`objdump -h *.o`命令查看到。

* **data段**（data segment）

  通常用来存放程序中**已经初始化的全局变量**的一块区域，或者用来存放**静态变量**（`static`)

* **text段**（code segment / text segment）

  通常是指用来存放程序执行代码的一块**内存区域**，这部分区域的大小在程序运行前已经确定，并且该内存区域通常属于**只读**，某些架构也允许代码段为可写，即允许**程序自修改（self-modifying code）** 

  在代码段中，也能包含一些只读的常数变量，例如字符串常量等。

  操作系统在装载一个程序时会进行进程地址空间的分段，代码段通常处于最底部，即最低地址部分，而堆和栈在最高处，所以在允许代码段可写的架构上，当堆和栈内存溢出的时候，代码段中的数据就会开始被覆盖。

* **rodata段**

  存放的是只读数据，字符串常量，全局`const`变量和`#define`定义的变量。本段又称为常量区

  这里`123456`就存放在rodata段中。

  但是注意，并不是所有的常量都放在`rodata`段的，其特殊情况如下：

  1) 有些立即数与指令编译在一起直接放在代码段；

  2. 对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份

  3. 有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率

* **strtab段**

  存储变量名、函数名等（注意，是名字）

* **shstrtab段**

  bss、text、data等段名也存储在这里

* **rel.text段**

  针对text段的重定位表，还有`rel.data`（针对data段的重定位表）

* **heap堆**

  堆是用于存放进程中被**动态分配**的内存段，他的大小并不固定，可动态扩张或所见。当进程调用`malloc()`等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用`free()`等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

* **stack栈**

  是用户存放程序**临时创建的局部变量**，也就是说我们函数括弧`{}`中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量（静态存储区））。除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存回栈中。

  由于栈的**先进后出**的特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上将，我们可以把栈安城一个寄存、交互按临时数据的内存区

  

## 虚拟内存

为每个进程提供了一个假象，即每个进程都在独占地使用主存。

每个进程看到的内存都是一致的，成为**虚拟地址空间**

![进程的虚拟地址空间](D:\KEXIEORGANIZATION\c\内存管理\进程的虚拟地址空间.png)

**机器级程序**：

* 对于机器级编程来说，其中两种重要抽象：
  1. **指令集体系结构**（定义机器级程序的格式和行为）：它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
  2. **机器级程序使用的存储器地址是虚拟地址**：提供的存储器模型看上去是个非常大的字节数组，实际上的实现是将多个硬件存储器和操作系统组合起来
     * **程序存储器**：程序的可执行机器代码、操作系统需要的一些信息、栈、堆。
     * 程序存储器用虚拟地址来寻址（此虚拟地址不是机器级虚拟地址），*操作系统负责管理虚拟地址空间（程序级虚拟地址），将虚拟地址翻译成实际处理器存储器中的物理地址（机器级虚拟地址）*

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**

内存的每个字节都由一个唯一的数字来标志，称为他的**地址**

所有可能地址的集合就成为**虚拟地址空间**，这个虚拟地址空间只是一个展现给机器级程序的概念性映像

