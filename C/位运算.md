# 位操作

在c语言中，可以单独操控变量中的位，听说是非常好用，那就来了解一下吧:hammer:

## 二进制数、位、字节

### 二进制整数

字节，表示存储系统字符集的大小，可能是8位、9位...

不过，描述**存储器芯片**和**数据传输率**中所用的是8位

* **高阶位**：编号7      
* **低阶位**：编号0

那么如何来表示有符号的二进制整数呢！接下来出场的嘉宾：**二进制补码**

二进制补码用一个字节中的后7位表示0~127，高阶位设置为0，如果表示**正数**那么就与普通的编号相同，如果表示负值，那么其中就有不同了：

1. 方法：从一个9位组合1e8（256的二进制形式）减去一个**负数**的位组合，结果是该负值的量
2. 例子：假设一个负值组合是 1e7，作为一个**无符号字节**，该组合表示128；但是**作为一个有符号字节**，该组合表示负值，值为100000000 - 10000000，即10000000（128），符号位负，则最终代表-128
3. 技巧：如果要得到一个二进制补码数的相反数，**反转每一位，然后加1** ，例如1是00000001，-1是11111110+1，为11111111



## C按位运算符

### 按位逻辑运算符

1. **二进制反码或按位取反：~**

   `~(1001)` 结果-> `(0110)`

   ```c
   unsigned char val = 2;
   newval = ~val; //val不会被改变，此时newval为val取反码后的值
   ```

2. **按位与：&**

   通过逐位比较两个运算对象，生成一个新值。**与**的逻辑关系为，两者都为1是，结果才为1

   `(11011) & (11000)` 结果-> `(11000)`

   C还有一个按位与和赋值结合的运算符：**&=** （就是类似*=和+=这种）

3. **按位或：|**

   通过逐位比较两个运算对象，生成一个新值。对于每个位，如果两个运算对象中相应的位为1，结果就为1

4. **按位异或： ^**

   通过逐位比较两个运算对象，对于每个位，如果两个运算对象中相应的位一个为1（**但不是两个都是1**），结果为1

   `(10010011) ^ (00111101)` 结果为-> `(10101110)`

#### 用法：掩码（mask）

所谓掩码，就是指一些设置为开或者关的位组合。到底是用来干什么的呢?

我们来举一个简单的例子（通过&）**使用掩码**：

假设 定义符号常量MASK为2（00000010） 定义flags变量中除1号位以外的所有位都设置为0

运行 `flags += flags & MASK`  所得结果1号位值不变，其他位都为0

<font color="red">这个过程叫做**使用掩码** 因为掩码中的0隐藏了flags中相应的位</font>

什么意思？其实就是根据&的性质，如果两位比较有一位为0，则不管另一位如何，这一位的结果都为0，因此我们可以将**掩码中为0的位置看作不透明**（不管掩码与其他如何比较，这一部分不透明的都为0），将**掩码中为1的位置看作透明**（因为此时结果的该位置上的数值取决于另一个数）

#### 用法：打开位（设置位）

有时，需要打开一个值中的特定位，同时保持其他位不变，这个时候就用**|**来实现。

以上面的flags和MASK为例，运行`flags = flags | MASK`

任何位与0组合，结果都为本身；任何位与1组合，结果都为1

#### 用法：关闭位（清空位）

和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。

`flags = flags & ~MASK`

以上方的flags和MASK为例子，~MASK除了1号位为0，其他位都为1，因此再利用&的关系，可知任何与1组合都得本身，所以这条语句保持其他位不变，改变1号位（事实上是不管其中是什么，都转化为0）

#### 用法：切换位

切换位指的是打开已关闭的位，或关闭已打开的位。

可以使用按位异或运算符（^）切换位，因为异或关系是使两者有一个位为1的时候结果为1（有且仅有这种情况）

因此，MASK中**为1的位置**可以使flags中相应的位置**改变值**，**为0的位置保持值不变**，从而达到切换位的效果

#### 用法：检查位的值

```c
if ((flags & MASK) == MASK)
    puts("!");
```

用于检查MASK中的一号位是不是为1

### 移位运算符

1. 左移 ：**<<**

   将左侧运算对象每一位的值向左移动其右侧运算对象指定的位数，左侧运算对象移出左末端位的值丢失，用0填充空出来的位置

   `(10001010) << 2` 所得结果为 `(00101000)`

2. 右移：**>>**

   将其左侧运算对象每一位的值向右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢失

   对于无符号类型，，用0填充空出来的位置

   对于有符号类型，其结果取决于机器

#### 用法

针对2的幂提供快速有效的乘法和除法

`number << n` number乘以2的n次

`number >> n` 如果number为非负，则用number除以2的n次
