- [C语言指针](#c语言指针)
  - [关于地址](#关于地址)
  - [指针的定义和初始化](#指针的定义和初始化)
    - [指针的简单运用](#指针的简单运用)
  - [指针与数组](#指针与数组)
    - [一维数组](#一维数组)
    - [二维数组](#二维数组)
    - [指针与字符串](#指针与字符串)
    - [指针数组和数组指针](#指针数组和数组指针)
  - [其他相关](#其他相关)
- [结构体](#结构体)
  - [复合字面量和结构](#复合字面量和结构)
  - [伸缩型数组成员](#伸缩型数组成员)
  - [匿名结构](#匿名结构)
  - [把结构内容保存到文件中](#把结构内容保存到文件中)

# C语言指针

## 关于地址

“指针就是用来存放地址的量。”  *那么，什么是地址呢？*

在电脑上运行的程序和所需要的数据都是在被电脑存储的基础上完成的。电脑的存储器分为两部分，**外部存储器**和**内部存储器**，简称外存和内存，而程序和数据被电脑存放在内存当中。内存是CPU能直接访问的存储空间，是一种以字节为单位的存储空间，每一个字节都有属于自己的**地址编号**，根据这种地址编号，我们就可以直接去读取我们所需要的数据。

指针，存放的就是这样的地址编号。

例如，在程序中定义的 int i，一个int类型的数据所占的字节数为4，此时若定义一个指针p指向i，则p中存储的为i所占内存的首地址。

```c
#include <stdio.h>

int main(){
    int i=0,j=0;
    printf("%d\n%d", &i, &j);
    return 0;
}
```

通过以上程序，查看输出的地址。

![QQ图片20211104170448](D:\科协学习报告\c\2021.11.6 c语言指针\QQ图片20211104170448.png)

输出结果可见，int类型所占内存的字节数为4，且指针存储的为首地址。



## 指针的定义和初始化

为了方便数据的读取，指针型变量被定义，通过这种直接存放变量地址的变量去访问变量。

```c
//数据类型 *变量名
  int *p;
/*此处定义了一个指针变量p，指向一个整数型变量*/
  char *c;
/*此处定义了一个指向字符变量的指针变量c*/
```

*在定义指针时，需要指定该指针指向的数据类型。*

```c
  int i;
  char j;
  int *i_pointer=&i;//i_pointer为一个指针变量，只存放地址，故取地址符
  char *j_pointer;
  *j_pointer=j;//*为指针运算符，即取指针指向的地址中存放的内容
```

由上述初始化可知,以下三种效果相同：

```c
 *j_pointer=j;
 j_pointer=&j;
 &(*j_pointer)=&j;
```

**注意：指针变量在定义后，一定要给其赋初值，若无特定数据，则可先给指针变量赋空值——空指针**

```c
char *pointer=NULL;
```

****

### 指针的简单运用

有了指针，可以通过指针来提高程序的效率。电脑在读取数据时，是先通过数据找到对应指针再进行输出地址中的数据，若我们直接通过指针（地址）来进行比较交换等操作，则可以简化数据读取的过程，达到效率的提高。

简单的数据交换：

1. 无自定义函数的直接交换

```c
#include <stdio.h>
    
int main(){
    int a,b;
    scanf("%d %d", &a, &b);
    int *pa = &a, *pb = &b, *p;
    if(a>b) {
        p=pa;
        pa=pb;
        pb=p;
    }
    printf("%d %d", *pa, *pb);
    return 0;
}
```

2. 放在自定义函数中的数据交换

   ```c
   #include <stdio.h>
   
   void swap(int *pa, int *pb);
   
   int main(){
       int a,b;
       int *pa=a; *pb=b;
       swap(*pa, *pb);
       printf("%d %d", a, b);
       return 0;
   }
   
   void swap(int *pa, int *pb){
       int *p;
       *p = *pa;/*在自定义函数中，无法通过改变形参来改变实参，但可以改变其地址中存放的数据*/
       *pa = *pb;                  
       *pb = *p;
   }
   ```

   上面这个代码会导致访问区域受限（错误），下面这个为**正确代码**：

   ```c
   #include <stdio.h>
   
   void swap(int* pa, int* pb);
   
   int main() {
       int a=1, b=2;
       
       swap(&a, &b);
       printf("%d %d", a, b);
       return 0;
   }
   
   void swap(int* pa, int* pb) {
       int temp = *pa;
       *pa = *pb;
       *pb = temp;
   }
   ```

   * <u>错误点1</u> ：在给第一个代码块中，给pa和pb赋值时，应采用 `int *pa = &a;` ` int *pb = &b;` **因为** 这里的*并不是取其内容，只是一个表示设置了指针变量的标志罢了
   * <u>错误点2</u> ： 第一个代码块中设置无用pa和pb的指针变量，多此一举更容易出错
   * <u>错误点3</u> ：在自定义函数中，不必再多设置一个指针变量，一个int类型就足够了

3. 利用指针的冒泡排序（输入n个数，将其从小到大进行排序）

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   void bubble(int *a,int n);
   
   int main(){
       int n, a[10];
       printf("请输入n（n<=10)");
       scanf("%d", &n);
       for(int i=0; i<n; i++){
           scanf("%d", &a[i]);
       }
       printf("排序过后：\n");
       bubble(a, n);
   
       for(int j=0; j<n; j++) {
               printf("%d ", *(a+j));
       }
       return 0;
   }
   
   void bubble(int *a, int n){
       int i,j;
       for(i=0; i<n-1; i++){
           for(j=0; j<n-i-1; j++){
               if(*(a+j)>*(a+j+1)){
                   int temp;
                   temp= *(a+j);
                   *(a+j)= *(a+j+1);
                   *(a+j+1)= temp;
               }
           }
       }
   }
   
   ```

   输出结果：

![冒泡排序的输出](D:\科协学习报告\c\2021.11.6 c语言指针\冒泡排序的输出.png)



*此处涉及数组的指针*



## 指针与数组

### 一维数组

>   在定义数组时，编译器必须分配基地址和足够的存储空间，以存储数组的所有元素。数组的基地址是在内存中存储数组的起始位置，它是数组的第一个元素（a[0]）的地址，因此数组名本身是一个地址即指针值。
>
> ​       指针是以地址作为值的变量，而数组名的值是一个特殊的固定地址，可以把它看作常量指针。

由以上简述的指针与数组的关系可知，若设置一个指针变量`int *p=a;`此时指针p指向的是a数组的第一个元素a[0]，p+1指向的为a数组的第二个元素a[1]，以此类推，p+i指向的为数组a的第i+1个元素a[i]，又根据`int`的特性可知其占4个字节，从程序观察指针之间的差别。

```c
#include <stdio.h>

int main(){
    int a[]={1,2,3,4};
    int *pa=a;
    for(int x=0; x<4; x++){
         printf("%d", pa+x);
    } 
    return 0;
}
```

我们用上面这个程序看一下数组中各个元素的地址，结果如下：

![数组元素的地址](D:\科协学习报告\c\2021.11.6 c语言指针\数组元素的地址.png)

****

那么，除了一维数组之外，**二维数组与指针**又有什么关系呢?

### 二维数组

当我们定义了一个二维数组 `int a[2][3]={{1,2,3},{1,2,3}}`,由上面的定义可以知道，a此时代表整个数组在内存中所占位子的首地址，将二维数组看成一个2*3表格，含有两行三列，此时根据二维数组本身的定义将二维数组的指针分为行指针和列指针（与a相关的指针表达方式）。

**行指针**： 

- `a`  `&a[0]` 指第0行的首地址
- `a+1` `&a[1]` 指第1行的首地址
- 以此类推，*`a+i` `&a[i]` 指第i行的首地址*

**列指针** ：

- `a[0]` `a[1]` ··· `a[i]` 指第i行第0列的首地址
-  *`a[i]+j` 指第i行第j列的首地址*
- `*(a+0)` `*(a+1)` ··· `*(a+i)` 指第i行第0列的首地址
- *`*(a+i)+j` 指第i行第j列的首地址*
- *`&a[i][j]` 指第i行第j列的首地址*

用一个程序来了解一下除了上述关于a的指针之外指向二维数组的指针

e.g  二维数组的输出

```c
#include <stdio.h>

int main(){
    int a[2][3]={{1,2,3},{3,4,5}};
    int *p;
    for(p=a[0]; p<a[0]+6; p++){    /*此处将二维数组第0行第0列的首地址赋值给指针变量p*/
        if((p-a[0])%3==0) printf("\n");
        printf("%4d", *p);
    }
    return 0;
}
```

输出结果：

![二维数组的输出](D:\科协学习报告\c\2021.11.6 c语言指针\二维数组的输出.png)



### 指针与字符串

赋给指针的是字符串的首地址，字符串一般都有一个数组来进行存储，也可以直接赋值于一个指针变量，来表示该字符串，事实上，字符串被存入了以该指针变量为名的数组中。在输出时遇到'\0'则代表字符串结束，输出结束。

e.g字符串的输出

```c
#include <stdio.h>

int main(){
    char *a="Hello,world!";
    for(int i=0; a[i]!='\0'; i++){
        printf("%c", a[i]);
    }
    return 0;
}
```

![字符串的输出](D:\科协学习报告\c\2021.11.6 c语言指针\字符串的输出.png)

程序中并未定义a数组，但是字符在内存中是以字符数组形式存放的。

e.g字符串的输入<u>（visual studio无法正常执行该程序？？？？）</u>

```c
#include <stdio.h>

int main(){
    char a[100];
    scanf("%s", a);
    printf("%s", a);
    return 0;
}
```

![字符串的输入](D:\科协学习报告\c\字符串的输入.png)

****

### 指针数组和数组指针

**指针数组**：顾名思义是由指针变量元素组成的数组。

```c
//类型名 *数组名[常量表达式]；
int *a[10];
//定义了一个含有10个指针变量的数组
```

> 指针数组对处理字符串提供了更大的方便和灵活性，使用二维数组对处理长度不等的正文效率低，而指针数组由于其中每个元素都是指针变量，因此通过地址运算来操作正文十分方便。
>
> e.g将若干个字符串按字母顺序输出
>
> ```c
> #include <stdio.h>
> #include <string.h>
> int main(){
>     char *name[]={"hello world","pointer", "I love China", "Great Wall"};
>     char *temp;
>     int k;
>     for(int i=0; i<3; i++){
>         k=i;
>         for(int j=i+1; j<4; j++){
>             if(strcmp(name[k],name[j])>0)
>                 k=j;
>         }
>         if(k!=i){
>             temp=name[i];
>             name[i]=name[k];
>             name[k]=temp;
>         }
> 
>     }
>     for(int x=0; x<4; x++){
>         printf("%s\n", name[x]);
>     }
>     return 0;
> }
> 
> ```
>
> 输出结果：
>
> ![指针数组](D:\科协学习报告\c\2021.11.6 c语言指针\字符串的输入.png)

**数组指针**：又叫行指针，指向一定长度的数组的指针

```c
int (*pa)[10];   /*指向长度为10的一维数组的指针*/
int a[25][10];   /*定义了一个认为数组a*/
pa=a;
```

通俗来讲，这里的pa事实上保存的就是数组a的第0行的地址（首地址），也可以说pa其实就是二维数组a的行指针。根据之前行指针的一系列定义，可以马上知道*(pa+i)+j 存储数组a第i行第j列的地址。

****

## 其他相关

1. malloc()函数和calloc()函数(在堆中为程序动态分配内存)

   两者作用差不多，同时有细微差距。

   ```c
   //malloc()
   void *malloc(unsigned int num_types);  //不会初始化
   //e.g
   (int *)malloc(10*4);  /*分配了40个字节的空间*/
   //calloc()
   void *calloc(unsigned n, unsigned s);   //将各个n个数初始化为0
   //e.g
   (int *)calloc(n, sizeof(int));
   ```

2. free()

    在变量运用结束后，收回分配的内存。

   ```c
   int *t,n;
   scanf("%d", &n);
   t = (int *)malloc(n*sizeof(int));
   ···  //省略代码
   free(t);
   return 0;
   ```

   

#  结构体

## 复合字面量和结构

可以用于结构和数组，创建临时结构值

```c
(struct book){"The Idiot", "Fyodor Dostoyevsky", 6.99}
```



## 伸缩型数组成员

伸缩型数组成员是结构的最后一个成员

结构中必须至少一个成员

方括号中是空的

```c
struct flex
{
    int count;
    double average;
    double scores[];  //伸缩型数组，不能然其做任何事
    
}

int main()
{
    struct flex* pf1, pf2;
    int n = 5;
    int i, tot = 0;
    //为结构和数组分配空间
    pf1 = malloc(sizeof(struct flex) + n * sizeof(double)) //怎么分配空间
    p->count = n;
    for(int i = 0; i < n; i++)
    {
        pf1->scores[i] = 20.0-i;
        tot += pf1->cores[i];
    }
    return 0;
}
```

**注意：** 

1. 不可以用结构进行复制和拷贝（可以用 memcpy() )
2. 不要按值方式把这中结构体传递给结构
3. 不要用带伸缩型数组的结构作为数组成员或者里一个结构的成员



## 匿名结构

没有名称的结构成员

```c
struct person
{
    int id;
    struct {char first[20]; char last[20]};  //匿名结构
};

struct person ted = {8489; {"Ted", "Grass"}}
```

在联合结构中更有用处 Union



## 把结构内容保存到文件中

结构可以存储不同类型的信息，所以它是构建数据库的重要工具。

数据库文件可以包含任意数量的数据对象。储存在一个结构中的整套信息被称为记录，单独的项被称为字段

`fwrite(&primer, sizeof(struct book), 1, pbooks);`

定位到primer结构变量开始的位置，并把结构中所有的字节（`sizeof(struct book)`）都拷贝到与pbooks相关的文件中。1，表示一次拷贝一块数据。

注：另一种带有同种参数的`fread()` 函数从文件中拷贝一块结构大小的数据到&primer指向的位置

两者读取的是整个记录，而不是字段

