- [宏](#宏)
  - [`#`运算符](#运算符)
  - [`##`运算符](#运算符-1)
  - [变参宏](#变参宏)
  - [其他指令](#其他指令)
  - [预定义宏](#预定义宏)
    - [`#line`和`#error`](#line和error)
  - [泛型选择](#泛型选择)
    - [泛型编程](#泛型编程)
    - [泛型表达式](#泛型表达式)
  - [内联函数（inline function）](#内联函数inline-function)
- [模块化编程](#模块化编程)
  - [项目](#项目)
  - [头文件](#头文件)
  - [多文件的全局变量](#多文件的全局变量)

# 宏

其实宏和函数完成的最终结构几乎相同，那么为什么不能都用函数呢？

事实上，这两者的**侧重点**有稍微的不同：

1. 宏生成**内联代码**，即在程序中生成语句，调用几次插入几次代码
   * 对空间不太友好
   * 时间上，不需要进行跳转，花费时间更小
2. 函数在使用的时候，程序中只有一份函数语句的副本，但是程序的控制必须跳转至函数内，随后再返回主调函数
   * 对空间友好
   * 对时间上，则不太ok

两者究竟如何选择，依靠各个部分的要求

## `#`运算符

在类函数宏的替换体中，#号作为一个预处理运算符，可以**把记号转换成字符串**

如果x是一个宏形参，那么#x就是转换为字符串”x“的形参名字，这个过程叫做**字符串化**

`#define PR(x) printf("The Ans of"#x"^2 is", ((x)*(x));`

输入：2

输出结果为：The Ans of 2^2 is 4

## `##`运算符

可以用于类函数宏的替换部分，还可以用于对象宏的替换部分

##运算符吧两个记号合成一个记号

下面用一个例子来说明：

```c
#include <stdio.h>
#define XNAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);
int main(void)
{
	int XNAME(1) = 14; // 变成 int x1 = 14;
	int XNAME(2) = 20; // 变成 int x2 = 20;
	int x3 = 30;
    PRINT_XN(1); // 变成 printf("x1 = %d\n", x1);
	PRINT_XN(2); // 变成 printf("x2 = %d\n", x2);
	PRINT_XN(3); // 变成 printf("x3 = %d\n", x3);
	return 0;
}
```

输出结果

```
x1 = 14
x2 = 20
x3 = 30
```



## 变参宏

一些函数可以接受数量可变的参数，那么那么在宏中也可分为不变宏和可变宏

**如何定义一个变参宏？**

1. 把宏参数列表最后的参数写成**省略号（...）**三个点
2. 预定义宏**`__VA_ARGS__`**可用在替换部分

举一个:chestnut:

```c
#define PR(...) printf(__VA_ARGS__)
//在下方利用这个宏
PR("Holly");
PR("weight = %d ship =%f", wt, sp);
//替换后：printf("Holly");
//printf("weight = %d ship =%f", wt, sp);
```

这样的形式就可以放置多个参数，在参数不一定的情况下



## 其他指令

1. **`#undef`指令**

   用于”取消“已定义的`#define`指令，移除之前的定义

   不过，如果你之前**并没有定义这个**，但是又不确定自己有没有定义，这种情况下，也可以使用`#undef`，更加安全

   :star2:已定义宏：对象宏，包括**空宏**或者**类函数宏**

2. **`#ifdef`、`#else` 和 `#endif`指令**

   * `#ifdef` 如果定义了则执行下面的指令
   * `#else` 如果没有则执行下面的指令（**非必要**）
   * `#endif`结束指令（**必须存在**）

   有一丢丢不好理解，直接把代码扔上来就好理解了！

   ```c
   #ifdef MAX //如果已经用#define定义了MAX
   #include "MAXX.h" //则执行下面的程序
   #define MIN 3
   #else //如果没有定义MAX
   #include "MAX.h"
   #define MIN 4
   #endif //停止
   ```

3. **`#ifndef`**指令

   和上面这个例子差不多，就是逻辑关系是相反的

   通常用于防止多次包含一个文件

   ```c
   #ifndef MAX_H_
   #define MAX_H_
   //其他代码块
   #endif
   ```

4. **`#if` 和`#elif`**指令

   其实就跟c中的if啥的很像



## 预定义宏

![预定义宏](D:\科协学习报告\c\预定义宏.png)

```c
#include <stdio.h>
void why_me();
int main()
{
	printf("The file is %s.\n", __FILE__);
	printf("The date is %s.\n", __DATE__);
	printf("The time is %s.\n", __TIME__);
	printf("The version is %ld.\n", __STDC_VERSION__);
	printf("This is line %d.\n", __LINE__);
	printf("This function is %s\n", __func__);  
    //__func__是预定义标识符，展开为一个代表函数名的字符串
	why_me();
	return 0;
}
void why_me()
{
	printf("This function is %s\n", __func__);
	printf("This is line %d.\n", __LINE__);
}
```

输出结果

```
The file is qsort.c.
The date is Dec 14 2021.
The time is 16:39:34.
The version is 201112.
This is line 9.
This function is main
This function is why_me
This is line 18.
```

### `#line`和`#error`

* `#line`指令重置`__LINE__`和`__FILE__`宏报告的行号和文件名 

  例如

  `#line 10000`   把当前行号重置为10000

  `#line 10 "max.h"` 把行号重置为10，把文件名重置为max.h

* `#error` 指令让预处理器发出一条错误信息，该消息包括指令中的文本，还可以让编译过程中止

  ```c
  #if __STDC_VERSION__ != 201112L
  #error Not C11
  #endif
  ```

* `#pragma` 指令把编译器指令放入源代码中

  编译器中，可以通过命令行参数或者IDE菜单修改编译器的一些设置

  ==......好像很复杂，下次再认真了解==

## 泛型选择

### 泛型编程

在了解泛型选择之前，我们先来看看更为广泛的大概念，**泛型编程**

> **泛型编程（generic programming）**指那些没有特定类型，但是一旦指定一种类型就可以转换成指定类型的代码。
>
> * 这是一种语言机制，通过它可以实现一个标准的容器库
> * 像类一样，是一种抽象数据类型
> * (好像是面向对象的编程 c中应该没有才对）
> * 事实上是**面向对象的补充和发展**

不理解，好像比较抽象，咱们来举个例子

> 在c++的模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。

:question:还是不太理解呢，让我们再接着看一个例子

就拿比较数据的大小来看

如果此时用户输入为**两个整型的数据**，我自然而然将代码写成

```c
int cmp(int a, int b)
{
    return (a>b)?a:b;
}
```

**那**，如果后来又要输入double类型的数据，我又要修改代码

```c
double cmp(double a, double b)
{
    return (a > b)?a : b;
}
```

那岂不是每次要根据输入改变我的代码了吗！:sob:

所以就出现了像这样的代码

```c
T cmp(T a, T b)
{
	return (a > b)? a: b;
}
```

当用户需要某个数据的比较值，直接把T换成我们所需要的类型就OK了，好像很方便的样子

这样子的编程方式就叫做**泛型编程**

那 **T** 又是什么东西，我怎么定义，我怎么转换？！

* T 事实上是一个类型占位符，在程序进行中会转化为具体的数据类型，至于是哪一个，根据需求而定

*  在泛型编程中的**T** 称为**泛型**（generic type）（一种数据类型）

* **注意**：

  > 泛型并不是真正的数据类型，那么泛型编写的代码也就不是真正的程序实体，只能算是一个**程序实体的样板**。
  >
  > 因此
  >
  > 通常形象的将这种使用了泛型的代码成为**模板**
  >
  > 由模板生成的实际代码的过程成为**模板的具体实现**

那么这些，在这里只用理解一个概念即可，具体的实现将会是c++中的内容

### 泛型表达式

我们知道泛型编程是一定程度上面向对象的编程，而c语言是面向过程的编程语言，因此这种方式在c中其实**并不适用**，但是，c中有一种与之类似的表达式，叫作**泛型选择表达式**(generic selection expression)

可根据表达式的类型选择一个值，虽然不是预处理器指令，但是常常作为`#define`宏定义的一部分

下面举一个泛型选择表达式的例子：

`_Generic(x, int: 0. float: 1, double: 2, default: 3)`

1. `_Generic` 是一个关键字，在圆括号里面包含多个项，并用逗号隔开。
   * 第一个项是**表达式**，后面的每个项都由一个类型、一个冒号和一个值组成
   * 第一个项的类型匹配哪个标签，整个表达式的值是该标签后面的值
   * **例如**，如果x是int类型的变量，x的类型匹配int：标签，那么整个表达式的值是0，如果都不是，那么就匹配default的标签后面的值

```c
#define MYTYPE(X) _Generic((X),\
int: "int",\
float: "float",\
double: "double",\
default: "other")
```

对于一个泛型选择表达式求值时，程序不会先对第一个项求值，他只确定类型，只有匹配标签的类型后才会对表达式求值

上去似乎很无用，如果我们把“int” “double”改成 fun1 fun2 ，冒号后面的键值改成函数就可以直接调用函数，则可以**作为一个接口函数使用**。

## 内联函数（inline function）

函数调用过程包括建立调用、传递参数、跳转到函数代码并返回。像，使用**宏**来内联代码，可以避免这样地调用消耗。

同时，C99中还有另一种方式：**内联函数**，引入`inline`关键词

关键词`inline`告诉编译器，任何地方只要调用内联函数，就直接把该函数的机械码插入到调用它的地方，这样可以提高程序执行效率

:question:那么那么，如何定义一个**内联函数**呢？又有哪些注意事项呢？

1. 定义时，需要在函数定义时，加上`inline`函数修饰符

   ```c
   inline int cmp(int a, int b)
   {
       return (a > b)? a: b;
   }
   ```

2. **注意**：可不能只加在函数声明开头，而是要和**函数定义体**放在一次才能内联

   因此，`inline`是一种“用于**实现**的关键字”

3. <font color="red">inline修饰符并非强制性的：编译器可能会不执行</font> 编译器有权自行决定是否要将有`inline`修饰符的函数编译成内联函数，例如递归函数等通常不会被内联。

   只适合**函数体内代码简单**的函数使用，不能包括复杂的结构控制语句，以及不能递归。

4. 在每个用到内联函数的翻译单元中，都必须**重新定义**这个内联函数，因此，经常在**头文件**中定义内联函数。

   有一点不同的是，在头文件中一般不放置可执行代码，但是对于内联函数是个例外

   因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题
   
5. 由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址，内联函数无法在调试器中显示



# 模块化编程

## 项目

要建立项目，把几个源代码文件（.c）加入进去。 这些源代码中只有一个`main()`函数



## 头文件

**只有声明可以放在头文件当中**，否则会造成一个项目中多个编译单元里有重名的实体

**易错点** ：头文件非常容易被多次定义，因此一般会在头文件中添加一点标识符

例如：

在头文件max.h中

```c
#ifndef _MAX_H_
#define _MAX_H_
//代码声明
#endif
```



把函数原型放到一个头文件（.h）中，在需要调用这个函数的源代码文件（.c）中#include这个头文件，就能让编译器知道这个函数的原型

在放置的同时也要注意其路径

```c
#include<stdio.h> // 尖括号表示查找系统目录
#include "max.h" // 查找当前工作目录
#include "/user/c/max.h" // 查找/user/c目录
```



总的而言，头文件中存放的是一堆函数声明，而源代码文件中存放的是函数本身

在新建后，在含有`main()`函数的源代码文件中，在开头预处理编译命令时，应添加`#include"max.h"`

**注意** ：#include 后面跟头文件的形式有两种：一种<>,一种""。第一种，让编译器只在指定的目录去找，第二			种，要求编译器首先在当前目录（.c所在文件的目录）寻找这个文件，如果没有，到编译器指定的目录去			找。*#include 会将声明直接插入，而非引入库* 

在**使用和定义**这个函数的地方都应该#include这个头文件（任何.c都有对应的同名.h，把多有**对外公开**的函数原型和全局变量的声明放进去。**不对外公开**的函数或者全局变量，只需要在函数前面加上`static` 就能使它成为只能在所在的编译单元中被使用的函数和全局变量）



## 多文件的全局变量

若在其他源代码文件(.c)中声明的全局变量想要用在含有`main()`函数的源代码文件中，应在对应头文件（.h）声明该全局变量的时候在前面加上`extern`

```c
extern int gAll;//赋值什么的都可以放在源代码文件中，头文件中一般就放个声明，声明不赋值，也不产生代码
int gAll; //这个是定义，可以进行赋值，会产生代码
```

****

